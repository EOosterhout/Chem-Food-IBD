##Title: Exploration of participant's chem data
##Author: Emily Oosterhout
## setwd('C:/DATA FOOD COMPONENT ANALYSIS/RP2_ChemIBDFood')
##

setwd('C:/DATA FOOD COMPONENT ANALYSIS/RP2_ChemIBDFood')
##========================= LOAD DATA AND IMPORT LIBRARIES =============================##

#Import libraries
library(readxl)
library(dplyr)
library(tidyverse)
library(data.table)
library(reshape2)
library(ggplot2)
library(ggbreak) 
library(patchwork)
library(rlang)
library(writexl)
#packages for testing/visualizing data distribution
library(ggpubr)
library(FSA)
#specific packages for PCA
library(ggfortify)
library(corrr)
library(corrplot)
library(factoextra)
library(MASS)
library(Hotelling)


# Load data
chem_part <- read_xlsx('chem_raw_participant.xlsx')
chem <- read_xlsx('transposed_ffqchem_V2.xlsx')
diet_raw <- read_xlsx('diet_raw_v2.xlsx')

##=============================== CLEANING AND SUBSETTING ==============================##

names(chem_part) = gsub(pattern = ":", replacement = "_", x = names(chem_part))

# Subset full participant intake to IBD and LLDEEP
IBD <- chem_part[chem_part$UMCGIBDResearchIDorLLDeepID %like% "UMCGIBD",]
LLDEEP <- chem_part[chem_part$UMCGIBDResearchIDorLLDeepID %like% "LLDeep",]

#Only chem intake IBD and LLDEEP
IBD_chem <- IBD[,7:1114]
LLDEEP_chem <- LLDEEP[,7:1114]

# Identify IBD participants
IBD_ID <- as.character(IBD$UMCGIBDResearchIDorLLDeepID)
# Create a new column specifying the group for each sample
chem_part$group <- ifelse(chem_part$UMCGIBDResearchIDorLLDeepID %in% IBD_ID, "IBD", "LLDEEP")

num_dat <- chem_part[,7:1114] #only selecting numerical from chem_part
chem_names <- colnames(num_dat)

##============================ SCALING OF RAW CHEM_PART ==============================##

## Common scaling methods are 
# Autoscaling (also known as standardization), where the responses for each variable are centered by subtracting its mean value and then divided by its standard deviation 
# Pareto scaling, where the mean-centered values are divided by the square root of the standard deviation.

# Calculate the percentage of non-zero values for each variable
non_zero_pct <- apply(num_dat != 0, 2, mean)
# Filter variables with at least a non-zero value in 10% of the data
filter_10pct <- num_dat[,non_zero_pct >= 0.1]
# Filter variables with at least a non-zero value in 20% of the data
filter_20pct <- num_dat[,non_zero_pct >= 0.2]

#add pseudocount to all variables and perform log-transformation
pseudo_chem <- filter_20pct + 1
log_chem <- log(pseudo_chem, 2)

#Function for Pareto scaling, which is recommended for metabolomics data
paretoscale <- function(z){
  colmean <- apply(z, 2, mean) # column means
  colsd <- apply(z, 2, sd) # column standard deviation
  colsqrtsd <- sqrt(colsd) # sqrt of sd
  rv <- sweep(z, 2, colmean, '-') # mean center
  rv <- sweep(rv, 2, colsqrtsd, '/') # devide by sqrtsd
  return(rv)
}

#scaling clean chem_dat
chem_num <- paretoscale(log_chem)

##=================================== PCA ANALYSIS FOOD METABOLITES: PARETO SCALING ==============================##

#PCA food metabolites on pareto scaled data
logchem_pca= prcomp(chem_num, scale. = F, center = F)

#store PCA results in df
pca_res <- summary(logchem_pca)
scree.data <- as.data.frame(pca_res$importance)
score.data <- as.data.frame(pca_res$x)
loadings.data <- as.data.frame(pca_res$rotation)

#Here I use the plots generated by factoextra library for a quick check but you can extract the data and repeat graphs using ggplot
#Check percentage of variance explained by each component
fviz_eig(logchem_pca, addlabels = T)

#PCA plot
fviz_pca_ind(logchem_pca, geom = "point",
             col.ind = "cos2", # Color by the quality of representation
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     # Avoid text overlapping
)

#Biplot
fviz_pca_biplot(logchem_pca, repel = TRUE, geom = "point",
                col.var = "#2E9FDF", # Variables color
                col.ind = "#696969",# Individuals color
                select.var= list(name=NULL, cos2=NULL, contrib=20) # contrib parameter top X individuals/variables with the highest contribution are drawn
)

# Color by cos2 values: quality on the factor map
fviz_pca_var(logchem_pca, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE # Avoid text overlapping
)

# Contributions of variables to PC1
fviz_contrib(logchem_pca, choice = "var", axes = 1, top = 20)
# Contributions of variables to PC2
fviz_contrib(logchem_pca, choice = "var", axes = 2, top = 20)


# Using ggplot to add diet and type of diet as factor in pca plot
chem.pca.var <- get_pca_ind(logchem_pca)
chem.pca.coord <- as.data.frame(chem.pca.var$coord)
chem.pca.coord.diet <- merge(chem_part, chem.pca.coord, by="row.names" )
chem.pca.contrib <- as.data.frame(chem.pca.var$contrib)
chem.pca.contrib.diet <- merge(chem_part, chem.pca.contrib, by="row.names" )

ggplot(chem.pca.contrib.diet, aes(Dim.1,Dim.2, fill=Diet)) + 
  geom_point(size=3,shape=21) + 
  theme_bw() +
  theme(legend.position = 'bottom',
        axis.text.x = element_text(vjust=0.5, size = 10)) 
ggplot(chem.pca.contrib.diet, aes(Dim.1,Dim.2, fill=type_of_diet)) + 
  geom_point(size=3,shape=21) + 
  theme_bw() + 
  theme(legend.position = 'bottom',
        axis.text.x = element_text(vjust=0.5, size = 10)) 

##=================================== PCA ANALYSIS FOOD METABOLITES: AUTO SCALING ==============================##

#PCA food metabolites on log transformed data
logchem_pca_auto= prcomp(log_chem,scale. = T, center = T)

#Here I use the plots generated by factoextra library for a quick check but you can extract the data and repeat graphs using ggplot
#Check percentage of variance explained by each component
fviz_eig(logchem_pca_auto, addlabels = T)

#PCA plot
fviz_pca_ind(logchem_pca_auto, geom = "point",
             col.ind = "cos2", # Color by the quality of representation
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     # Avoid text overlapping
)

#Biplot
fviz_pca_biplot(logchem_pca_auto, repel = TRUE, geom = "point",
                col.var = "#2E9FDF", # Variables color
                col.ind = "#696969",# Individuals color
                select.var= list(name=NULL, cos2=NULL, contrib=20) # contrib parameter top X individuals/variables with the highest contribution are drawn
)

# Color by cos2 values: quality on the factor map
fviz_pca_var(logchem_pca_auto, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE # Avoid text overlapping
)

# Contributions of variables to PC1
fviz_contrib(logchem_pca_auto, choice = "var", axes = 1, top = 20)
# Contributions of variables to PC2
fviz_contrib(logchem_pca_auto, choice = "var", axes = 2, top = 20)

#store PCA results in df
pca_res <- summary(logchem_pca_auto)
scree.data <- as.data.frame(pca_res$importance)
score.data <- as.data.frame(pca_res$x)
loadings.data <- as.data.frame(pca_res$rotation)

# Using ggplot to add diet and type of diet as factor in pca plot
chem.pca.var <- get_pca_ind(logchem_pca)
chem.pca.coord <- as.data.frame(chem.pca.var$coord)
chem.pca.coord.diet <- merge(chem_part, chem.pca.coord, by="row.names" )
chem.pca.contrib <- as.data.frame(chem.pca.var$contrib)
chem.pca.contrib.diet <- merge(chem_part, chem.pca.contrib, by="row.names" )

ggplot(chem.pca.contrib.diet, aes(Dim.1,Dim.2, fill=Diet)) + 
  geom_point(size=3,shape=21) + 
  theme_bw() +
  theme(legend.position = 'bottom',
        axis.text.x = element_text(vjust=0.5, size = 10)) 
ggplot(chem.pca.contrib.diet, aes(Dim.1,Dim.2, fill=type_of_diet)) + 
  geom_point(size=3,shape=21) + 
  theme_bw() + 
  theme(legend.position = 'bottom',
        axis.text.x = element_text(vjust=0.5, size = 10)) 

##=================================== TEST DIFFERENCES BETWEEN IBD AND CONTROL: T-TEST =================================##

#function that creates a new data object containing descriptive statistics
sumstats <- function(z){
  Mean <- apply(z, 2, mean)
  Median <- apply(z, 2, median)
  SD <- apply(z, 2, sd)
  SE <- apply(z, 2, function(x) sd(x)/sqrt(length(x)))
  CV <- apply(z, 2, function(x) sd(x)/mean(x))
  result <- data.frame(Mean, Median, SD, SE, CV)
  return(result)
}

#apply descriptive statistics function 
stat_IBD <- sumstats(IBD_chem) # IBD patients
stat_IBD$group <- 'IBD'
stat_LLDEEP <- sumstats(LLDEEP_chem) # LLDEEP participants
stat_LLDEEP$group <- 'LLDEEP'
stat_chem <- rbind(stat_IBD, stat_LLDEEP) # full chem data

## T-TEST ##

# Create an empty list to store the results of t-test
results <- list()
# Loop through the variables and perform t-test for each element
for (var in chem_names) {
  temp <- t.test(chem_part[chem_part$group == "IBD", var], chem_part[chem_part$group == "LLDEEP", var])
    results[[var]] <- temp
}

# Filter significant differences (p<0.05) and exclude NaN and NA values
significant_results <- list()
for (i in chem_names) {
  # Check if p-value is significant and exclude NaN and NA values
  if (!is.na(results[[i]]$p.value) & !is.nan(results[[i]]$p.value) & results[[i]]$p.value < 0.05) {
    significant_results[[i]] <- results[[i]]
  }
}

# convert chem_part to long format
melted_data <- melt(chem_part, id.vars = "group", measure.vars = chem_names)

filtered_data <- list()
for (var in names(significant_results)) {
  # Filter data for significant variable
  filtered_data <- melted_data[melted_data$variable == var,]
  filtered_data[[var]] <- out
}

filtered_data <- rbindlist(filtered_data)

         #Boxplots of significant t-test results (p < 0.05)#

box_plots <- list()
for (var in names(significant_results)) {
  # Filter data for significant variable
  filtered_data <- melted_data[melted_data$variable == var, ]
  
  # Create box plot using ggplot
  plot <- ggplot(filtered_data, aes(x = group, y = value, fill = group)) + 
    geom_boxplot() + 
    ggtitle(var) +
    geom_text(aes(x = 1.5, y = max(filtered_data$value), label = paste0("p = ", signif(significant_results[[var]]$p.value, 2))), 
              size = 5, hjust = 0.5, vjust = 1.5)
  box_plots[[var]] <- plot
  
  # Create directory for the output files if it doesn't exist
  if (!dir.exists("output")) {
    dir.create("output")
  }
  
  # Save the box plot as PNG file in the output folder
  filename <- paste0("output/", var, ".png")
  ggsave(filename, plot = plot, width = 6, height = 4, dpi = 300)
}


# Filter significant differences (p < 0.01) and exclude NaN and NA values
significant_results_small <- list()
for (i in chem_names) {
  # Check if p-value is significant and exclude NaN and NA values
  if (!is.na(results[[i]]$p.value) & !is.nan(results[[i]]$p.value) & results[[i]]$p.value < 0.01) {
    significant_results_small[[i]] <- results[[i]]
  }
}

                   #Boxplots of T-test results (p < 0.01)#

box_plots <- list()
for (var in names(significant_results_small)) {
  # Filter data for significant variable
  filtered_data <- melted_data[melted_data$variable == var, ]
  
  # Create box plot using ggplot
  plot <- ggplot(filtered_data, aes(x = group, y = value, fill = group)) + 
    geom_boxplot() + 
    ggtitle(var) +
    geom_text(aes(x = 1.5, y = max(filtered_data$value), label = paste0("p = ", signif(significant_results_small[[var]]$p.value, 2))), 
              size = 5, hjust = 0.5, vjust = 1.5)
  box_plots[[var]] <- plot
  
  # Create directory for the output files if it doesn't exist
  if (!dir.exists("output_small")) {
    dir.create("output_small")
  }
  
  # Save the box plot as PNG file in the output folder
  filename <- paste0("output_small/", var, ".png")
  ggsave(filename, plot = plot, width = 6, height = 4, dpi = 300)
}



##===================================== T-TEST ON LOG TRANSFORMED AND FILTERED CHEM DATA ====================================================##

# Calculate the percentage of non-zero values for each variable
non_zero_pct <- apply(num_dat != 0, 2, mean)
# Filter variables with at least a non-zero value in 10% of the data
filter_10pct <- num_dat[,non_zero_pct >= 0.1]
# Filter variables with at least a non-zero value in 20% of the data
filter_20pct <- num_dat[,non_zero_pct >= 0.2]

#add pseudocount to all variables and perform log-transformation
pseudo_chem <- filter_20pct + 1
log_chem <- log(pseudo_chem, 2)

# Create a new column specifying the group for each sample
log_chem$group <- ifelse(chem_part$UMCGIBDResearchIDorLLDeepID %in% IBD_ID, "IBD", "LLDEEP")
names <- names(pseudo_chem)
## T-TEST ##

# Create an empty list to store the results of t-test
results_log <- list()
# Loop through the variables and perform t-test for each element
for (var in names) {
  temp <- t.test(log_chem[log_chem$group == "IBD", var], log_chem[log_chem$group == "LLDEEP", var])
  results_log[[var]] <- temp
}

# Filter significant differences (p<0.001) and exclude NaN and NA values
significant_results_log <- list()
for (i in names) {
  # Check if p-value is significant and exclude NaN and NA values
  if (!is.na(results[[i]]$p.value) & !is.nan(results_log[[i]]$p.value) & results_log[[i]]$p.value < 0.001) {
    significant_results_log[[i]] <- results_log[[i]]
  }
}

# Filter significant differences and exclude NaN and NA values
significant_results_log_est <- list()
for (var in names) {
  # Check if p-value is significant and the difference in estimate is greater than 1.0
  if (!is.na(results_log[[var]]$p.value) & !is.nan(results_log[[var]]$p.value) & 
      results_log[[var]]$p.value < 0.001 & abs(results_log[[var]]$estimate[1] - results_log[[var]]$estimate[2]) > 2.0) {
    significant_results_log_est[[var]] <- results_log[[var]]
  }
}

# convert log_chem to long format
melted_data_log_est <- melt(log_chem, id.vars = "group", measure.vars = names(significant_results_log_est))

                    #Boxplots of T-test results (p < 0.001)#

box_plots <- list()
for (var in names(significant_results_log_est)) {
  # Filter data for significant variable
  filtered_data <- melted_data_log[melted_data_log$variable == var, ]
  
  # Create box plot using ggplot
  plot <- ggplot(filtered_data, aes(x = group, y = value, fill = group)) + 
    geom_boxplot() + 
    ggtitle(var) +
    geom_text(aes(x = 1.5, y = max(filtered_data$value), label = paste0("p = ", signif(significant_results_log_est[[var]]$p.value, 2))), 
              size = 5, hjust = 0.5, vjust = 1.5)
  box_plots[[var]] <- plot
  
  # Create directory for the output files if it doesn't exist
  if (!dir.exists("output_log_est")) {
    dir.create("output_log_est")
  }
  
  # Save the box plot as PNG file in the output folder
  filename <- paste0("output_log_est/", var, ".png")
  ggsave(filename, plot = plot, width = 6, height = 4, dpi = 300)
}
