##Title: Exploration of participant's chem data
##Author: Emily Oosterhout
## setwd('C:/DATA FOOD COMPONENT ANALYSIS/RP2_ChemIBDFood')
##

setwd('C:/DATA FOOD COMPONENT ANALYSIS/RP2_ChemIBDFood')
##========================= LOAD DATA AND IMPORT LIBRARIES =============================##

#Import libraries
library(readxl)
library(dplyr)
library(tidyverse)
library(data.table)
library(reshape2)
library(ggplot2)
library(ggbreak) 
library(patchwork)
library(rlang)
library(writexl)
#packages for testing/visualizing data distribution
library(ggpubr)
library(FSA)
#specific packages for PCA
library(ggfortify)
library(corrr)
library(corrplot)
library(factoextra)
library(MASS)


# Load data
chem_part <- read_xlsx('chem_raw_participant.xlsx')
chem <- read_xlsx('transposed_ffqchem_V2.xlsx')
diet_raw <- read_xlsx('diet_raw_v2.xlsx')

##=============================== CLEANING AND SCALING OF RAW CHEM_PART ==============================##

num_dat <- chem_part[,7:1114] #only selecting numerical from chem_part

#Function that finds the minimum nonzero values and removes all zero variables
replacezero_and_removezerocols <- function(dataframe) {
  # Remove columns where all values are zero
  non_zero_cols <- apply(dataframe, 2, function(col) any(col != 0))
  dataframe <- dataframe[, non_zero_cols]
  
  # Find the minimum nonzero value in each column
  min_nonzero <- apply(dataframe, 2, function(col) min(col[col > 0]))
  
  # Replace zero values with the minimum nonzero value in each column
  for (i in 1:ncol(dataframe)) {
    dataframe[dataframe[, i] == 0, i] <- min_nonzero[i]
  }
  
  return(dataframe)
}

# Apply replacezero() to num_dat
chem_part_clean <- replacezero_and_removezerocols(num_dat)

#Function for Pareto scaling, which is recommended for metabolomics data
paretoscale <- function(z){
  colmean <- apply(z, 2, mean) # column means
  colsd <- apply(z, 2, sd) # column standard deviation
  colsqrtsd <- sqrt(colsd) # sqrt of sd
  rv <- sweep(z, 2, colmean, '-') # mean center
  rv <- sweep(rv, 2, colsqrtsd, '/') # devide by sqrtsd
  return(rv)
}

## Common scaling methods are 
   # Autoscaling (also known as standardization), where the responses for each variable are centered by subtracting its mean value and then divided by its standard deviation 
   # Pareto scaling, where the mean-centered values are divided by the square root of the standard deviation.

#scaling clean chem_dat
chem_num <- paretoscale(chem_part_clean) # --> returns NaN when performed on log transformed data?

##=================================== PCA ANALYSIS FOOD METABOLITES ==============================##

#PCA food metabolites
chem_pca= prcomp(chem_num, scale. = F, center = F)
#Here I use the plots generated by factoextra library for a quick check but you can extract the data and repeat graphs using ggplot

#Check percentage of variance explained by each component
fviz_eig(chem_pca, addlabels = T)

#PCA plot
fviz_pca_ind(chem_pca, geom = "point",
             col.ind = "cos2", # Color by the quality of representation
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     # Avoid text overlapping
)

#Biplot
fviz_pca_biplot(chem_pca, repel = TRUE, geom = "point",
                col.var = "#2E9FDF", # Variables color
                col.ind = "#696969",# Individuals color
                select.var= list(name=NULL, cos2=NULL, contrib=10) # contrib parameter top X individuals/variables with the highest contribution are drawn
)

# Color by cos2 values: quality on the factor map
fviz_pca_var(chem_pca, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE # Avoid text overlapping
)

# Contributions of variables to PC1
fviz_contrib(chem_pca, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(chem_pca, choice = "var", axes = 2, top = 10)


# Using ggplot to add diet and type of diet as factor in pca plot
chem.pca.var <- get_pca_ind(chem_pca)
chem.pca.coord <- as.data.frame(chem.pca.var$coord)
chem.pca.coord.diet <- merge(chem_part, chem.pca.coord, by="row.names" )
chem.pca.contrib <- as.data.frame(chem.pca.var$contrib)
chem.pca.contrib.diet <- merge(chem_part, chem.pca.contrib, by="row.names" )

ggplot(chem.pca.contrib.diet, aes(Dim.1,Dim.2, fill=Diet)) + 
  geom_point(size=3,shape=21) + 
  theme_bw() +
  theme(legend.position = 'bottom',
        axis.text.x = element_text(vjust=0.5, size = 10)) 
ggplot(chem.pca.contrib.diet, aes(Dim.1,Dim.2, fill=type_of_diet)) + 
  geom_point(size=3,shape=21) + 
  theme_bw() + 
  theme(legend.position = 'bottom',
        axis.text.x = element_text(vjust=0.5, size = 10)) 


##=================================== TEST DIFFERENCES BETWEEN IBD AND CONTROL =================================##

# Subset full participant intake to IBD and LLDEEP
IBD <- chem_part[chem_part$UMCGIBDResearchIDorLLDeepID %like% "UMCGIBD",]
LLDEEP <- chem_part[chem_part$UMCGIBDResearchIDorLLDeepID %like% "LLDeep",]

#Only chem intake IBD and LLDEEP
IBD_chem <- IBD[,7:1114]
LLDEEP_chem <- LLDEEP[,7:1114]

# Identify IBD participants
IBD_ID <- as.character(IBD$UMCGIBDResearchIDorLLDeepID)
# Create a new column specifying the group for each sample
chem_part$group <- ifelse(chem_part$UMCGIBDResearchIDorLLDeepID %in% IBD_ID, "IBD", "LLDEEP")

# Get intersection of variable names between the two groups
common_vars <- intersect(names(IBD)[-1], names(LLDEEP)[-1])

#function that creates a new data object containing descriptive statistics
sumstats <- function(z){
  Mean <- apply(z, 2, mean)
  Median <- apply(z, 2, median)
  SD <- apply(z, 2, sd)
  SE <- apply(z, 2, function(x) sd(x)/sqrt(length(x)))
  CV <- apply(z, 2, function(x) sd(x)/mean(x))
  result <- data.frame(Mean, Median, SD, SE, CV)
  return(result)
}

#apply descriptive statistics function 
stat_chem <- sumstats(num_dat) # full chem data
stat_IBD <- sumstats(IBD_chem) # IBD patients
stat_LLDEEP <- sumstats(LLDEEP_chem) # LLDEEP participants

#df with numeric data based on group
chem_group <- chem_part[,7:1115]
group_chem <- chem_group %>%
  relocate(group)


